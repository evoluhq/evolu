diff --git a/dist/changesets-assemble-release-plan.cjs.js b/dist/changesets-assemble-release-plan.cjs.js
index 60427457c887f2d72168fecec83d79088c68e3a4..394d607a3c56d6f5142bc4a9db1bb6dfac41f540 100644
--- a/dist/changesets-assemble-release-plan.cjs.js
+++ b/dist/changesets-assemble-release-plan.cjs.js
@@ -1,26 +1,30 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+Object.defineProperty(exports, "__esModule", { value: true });
 
-var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
-var errors = require('@changesets/errors');
-var getDependentsGraph = require('@changesets/get-dependents-graph');
-var shouldSkipPackage = require('@changesets/should-skip-package');
-var semverParse = require('semver/functions/parse');
-var semverGt = require('semver/functions/gt');
-var semverSatisfies = require('semver/functions/satisfies');
-var semverInc = require('semver/functions/inc');
+var _objectSpread = require("@babel/runtime/helpers/objectSpread2");
+var errors = require("@changesets/errors");
+var getDependentsGraph = require("@changesets/get-dependents-graph");
+var shouldSkipPackage = require("@changesets/should-skip-package");
+var semverParse = require("semver/functions/parse");
+var semverGt = require("semver/functions/gt");
+var semverSatisfies = require("semver/functions/satisfies");
+var semverInc = require("semver/functions/inc");
 
-function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }
+function _interopDefault(e) {
+  return e && e.__esModule ? e : { default: e };
+}
 
-var semverParse__default = /*#__PURE__*/_interopDefault(semverParse);
-var semverGt__default = /*#__PURE__*/_interopDefault(semverGt);
-var semverSatisfies__default = /*#__PURE__*/_interopDefault(semverSatisfies);
-var semverInc__default = /*#__PURE__*/_interopDefault(semverInc);
+var semverParse__default = /*#__PURE__*/ _interopDefault(semverParse);
+var semverGt__default = /*#__PURE__*/ _interopDefault(semverGt);
+var semverSatisfies__default = /*#__PURE__*/ _interopDefault(semverSatisfies);
+var semverInc__default = /*#__PURE__*/ _interopDefault(semverInc);
 
 function getHighestReleaseType(releases) {
   if (releases.length === 0) {
-    throw new Error(`Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`);
+    throw new Error(
+      `Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`
+    );
   }
 
   let highestReleaseType = "none";
@@ -52,11 +56,16 @@ function getCurrentHighestVersion(packageGroup, packagesByName) {
     let pkg = packagesByName.get(pkgName);
 
     if (!pkg) {
-      console.error(`FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`);
+      console.error(
+        `FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`
+      );
       throw new Error(`fatal: could not resolve linked packages`);
     }
 
-    if (highestVersion === undefined || semverGt__default["default"](pkg.packageJson.version, highestVersion)) {
+    if (
+      highestVersion === undefined ||
+      semverGt__default["default"](pkg.packageJson.version, highestVersion)
+    ) {
       highestVersion = pkg.packageJson.version;
     }
   }
@@ -82,12 +91,18 @@ function applyLinks(releases, packagesByName, linked) {
 
   for (let linkedPackages of linked) {
     // First we filter down to all the relevant releases for one set of linked packages
-    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none"); // If we proceed any further we do extra work with calculating highestVersion for things that might
+    let releasingLinkedPackages = [...releases.values()].filter(
+      (release) =>
+        linkedPackages.includes(release.name) && release.type !== "none"
+    ); // If we proceed any further we do extra work with calculating highestVersion for things that might
     // not need one, as they only have workspace based packages
 
     if (releasingLinkedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingLinkedPackages);
-    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(
+      linkedPackages,
+      packagesByName
+    ); // Finally, we update the packages so all of them are on the highest version
 
     for (let linkedPackage of releasingLinkedPackages) {
       if (linkedPackage.type !== highestReleaseType) {
@@ -116,11 +131,12 @@ function incrementVersion(release, preInfo) {
     let preVersion = preInfo.preVersions.get(release.name);
 
     if (preVersion === undefined) {
-      throw new errors.InternalError(`preVersion for ${release.name} does not exist when preState is defined`);
+      throw new errors.InternalError(
+        `preVersion for ${release.name} does not exist when preState is defined`
+      );
     } // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
     // because semver.inc with prereleases is confusing and this seems easier
 
-
     version += `-${preInfo.state.tag}.${preVersion}`;
   }
 
@@ -144,7 +160,7 @@ function determineDependents({
   packagesByName,
   dependencyGraph,
   preInfo,
-  config
+  config,
 }) {
   let updated = false; // NOTE this is intended to be called recursively
 
@@ -158,96 +174,101 @@ function determineDependents({
     const pkgDependents = dependencyGraph.get(nextRelease.name);
 
     if (!pkgDependents) {
-      throw new Error(`Error in determining dependents - could not find package in repository: ${nextRelease.name}`);
+      throw new Error(
+        `Error in determining dependents - could not find package in repository: ${nextRelease.name}`
+      );
     }
 
-    pkgDependents.map(dependent => {
-      let type;
-      const dependentPackage = packagesByName.get(dependent);
-      if (!dependentPackage) throw new Error("Dependency map is incorrect");
-
-      if (shouldSkipPackage.shouldSkipPackage(dependentPackage, {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
-        type = "none";
-      } else {
-        const dependencyVersionRanges = getDependencyVersionRanges(dependentPackage.packageJson, nextRelease);
-
-        for (const {
-          depType,
-          versionRange
-        } of dependencyVersionRanges) {
-          if (nextRelease.type === "none") {
-            continue;
-          } else if (shouldBumpMajor({
-            dependent,
-            depType,
-            versionRange,
-            releases,
-            nextRelease,
-            preInfo,
-            onlyUpdatePeerDependentsWhenOutOfRange: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.onlyUpdatePeerDependentsWhenOutOfRange
-          })) {
-            type = "major";
-          } else if ((!releases.has(dependent) || releases.get(dependent).type === "none") && (config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.updateInternalDependents === "always" || !semverSatisfies__default["default"](incrementVersion(nextRelease, preInfo), versionRange))) {
-            switch (depType) {
-              case "dependencies":
-              case "optionalDependencies":
-              case "peerDependencies":
-                if (type !== "major" && type !== "minor") {
-                  type = "patch";
-                }
+    pkgDependents
+      .map((dependent) => {
+        let type;
+        const dependentPackage = packagesByName.get(dependent);
+        if (!dependentPackage) throw new Error("Dependency map is incorrect");
+
+        if (
+          shouldSkipPackage.shouldSkipPackage(dependentPackage, {
+            ignore: config.ignore,
+            allowPrivatePackages: config.privatePackages.version,
+          })
+        ) {
+          type = "none";
+        } else {
+          const dependencyVersionRanges = getDependencyVersionRanges(
+            dependentPackage.packageJson,
+            nextRelease
+          );
+
+          for (const { depType, versionRange } of dependencyVersionRanges) {
+            if (nextRelease.type === "none") {
+              continue;
+            } else if (
+              (!releases.has(dependent) ||
+                releases.get(dependent).type === "none") &&
+              (config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
+                .updateInternalDependents === "always" ||
+                !semverSatisfies__default["default"](
+                  incrementVersion(nextRelease, preInfo),
+                  versionRange
+                ))
+            ) {
+              switch (depType) {
+                case "dependencies":
+                case "optionalDependencies":
+                case "peerDependencies":
+                  if (type !== "major" && type !== "minor") {
+                    type = "patch";
+                  }
 
-                break;
+                  break;
 
-              case "devDependencies":
-                {
+                case "devDependencies": {
                   // We don't need a version bump if the package is only in the devDependencies of the dependent package
-                  if (type !== "major" && type !== "minor" && type !== "patch") {
+                  if (
+                    type !== "major" &&
+                    type !== "minor" &&
+                    type !== "patch"
+                  ) {
                     type = "none";
                   }
                 }
+              }
             }
           }
         }
-      }
 
-      if (releases.has(dependent) && releases.get(dependent).type === type) {
-        type = undefined;
-      }
+        if (releases.has(dependent) && releases.get(dependent).type === type) {
+          type = undefined;
+        }
 
-      return {
-        name: dependent,
-        type,
-        pkgJSON: dependentPackage.packageJson
-      };
-    }).filter(dependentItem => !!dependentItem.type).forEach(({
-      name,
-      type,
-      pkgJSON
-    }) => {
-      // At this point, we know if we are making a change
-      updated = true;
-      const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
-      // added them here. If we have, we update the existing item instead of pushing it on to search.
-      // It is safe to not add it to pkgsToSearch because it should have already been searched at the
-      // largest possible bump type.
-
-      if (existing && type === "major" && existing.type !== "major") {
-        existing.type = "major";
-        pkgsToSearch.push(existing);
-      } else {
-        let newDependent = {
-          name,
+        return {
+          name: dependent,
           type,
-          oldVersion: pkgJSON.version,
-          changesets: []
+          pkgJSON: dependentPackage.packageJson,
         };
-        pkgsToSearch.push(newDependent);
-        releases.set(name, newDependent);
-      }
-    });
+      })
+      .filter((dependentItem) => !!dependentItem.type)
+      .forEach(({ name, type, pkgJSON }) => {
+        // At this point, we know if we are making a change
+        updated = true;
+        const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
+        // added them here. If we have, we update the existing item instead of pushing it on to search.
+        // It is safe to not add it to pkgsToSearch because it should have already been searched at the
+        // largest possible bump type.
+
+        if (existing && type === "major" && existing.type !== "major") {
+          existing.type = "major";
+          pkgsToSearch.push(existing);
+        } else {
+          let newDependent = {
+            name,
+            type,
+            oldVersion: pkgJSON.version,
+            changesets: [],
+          };
+          pkgsToSearch.push(newDependent);
+          releases.set(name, newDependent);
+        }
+      });
   }
 
   return updated;
@@ -259,27 +280,38 @@ function determineDependents({
 */
 
 function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
-  const DEPENDENCY_TYPES = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
+  const DEPENDENCY_TYPES = [
+    "dependencies",
+    "devDependencies",
+    "peerDependencies",
+    "optionalDependencies",
+  ];
   const dependencyVersionRanges = [];
 
   for (const type of DEPENDENCY_TYPES) {
     var _dependentPkgJSON$typ;
 
-    const versionRange = (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null || _dependentPkgJSON$typ === void 0 ? void 0 : _dependentPkgJSON$typ[dependencyRelease.name];
+    const versionRange =
+      (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null ||
+      _dependentPkgJSON$typ === void 0
+        ? void 0
+        : _dependentPkgJSON$typ[dependencyRelease.name];
     if (!versionRange) continue;
 
     if (versionRange.startsWith("workspace:")) {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange: // intentionally keep other workspace ranges untouched
-        // this has to be fixed but this should only be done when adding appropriate tests
-        versionRange === "workspace:*" ? // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
-        dependencyRelease.oldVersion : versionRange.replace(/^workspace:/, "")
+        // intentionally keep other workspace ranges untouched
+        versionRange:
+          // this has to be fixed but this should only be done when adding appropriate tests
+          versionRange === "workspace:*" // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
+            ? dependencyRelease.oldVersion
+            : versionRange.replace(/^workspace:/, ""),
       });
     } else {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange
+        versionRange,
       });
     }
   }
@@ -294,57 +326,70 @@ function shouldBumpMajor({
   releases,
   nextRelease,
   preInfo,
-  onlyUpdatePeerDependentsWhenOutOfRange
+  onlyUpdatePeerDependentsWhenOutOfRange,
 }) {
   // we check if it is a peerDependency because if it is, our dependent bump type might need to be major.
-  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && ( // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
-  // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
-  !onlyUpdatePeerDependentsWhenOutOfRange || !semverSatisfies__default["default"](incrementVersion(nextRelease, preInfo), versionRange)) && ( // bump major only if the dependent doesn't already has a major release.
-  !releases.has(dependent) || releases.has(dependent) && releases.get(dependent).type !== "major");
+  return (
+    depType === "peerDependencies" &&
+    nextRelease.type !== "none" &&
+    nextRelease.type !== "patch" && // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
+    // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
+    (!onlyUpdatePeerDependentsWhenOutOfRange ||
+      !semverSatisfies__default["default"](
+        incrementVersion(nextRelease, preInfo),
+        versionRange
+      )) && // bump major only if the dependent doesn't already has a major release.
+    (!releases.has(dependent) ||
+      (releases.has(dependent) && releases.get(dependent).type !== "major"))
+  );
 }
 
 // This function takes in changesets and returns one release per
 function flattenReleases(changesets, packagesByName, config) {
   let releases = new Map();
-  changesets.forEach(changeset => {
+  changesets.forEach((changeset) => {
     changeset.releases // Filter out skipped packages because they should not trigger a release
-    // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
-    .filter(({
-      name
-    }) => !shouldSkipPackage.shouldSkipPackage(packagesByName.get(name), {
-      ignore: config.ignore,
-      allowPrivatePackages: config.privatePackages.version
-    })).forEach(({
-      name,
-      type
-    }) => {
-      let release = releases.get(name);
-      let pkg = packagesByName.get(name);
-
-      if (!pkg) {
-        throw new Error(`"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`);
-      }
-
-      if (!release) {
-        release = {
-          name,
-          type,
-          oldVersion: pkg.packageJson.version,
-          changesets: [changeset.id]
-        };
-      } else {
-        if (type === "major" || (release.type === "patch" || release.type === "none") && (type === "minor" || type === "patch")) {
-          release.type = type;
-        } // Check whether the bumpType will change
-        // If the bumpType has changed recalc newVersion
-        // push new changeset to releases
-
+      // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
+      .filter(
+        ({ name }) =>
+          !shouldSkipPackage.shouldSkipPackage(packagesByName.get(name), {
+            ignore: config.ignore,
+            allowPrivatePackages: config.privatePackages.version,
+          })
+      )
+      .forEach(({ name, type }) => {
+        let release = releases.get(name);
+        let pkg = packagesByName.get(name);
+
+        if (!pkg) {
+          throw new Error(
+            `"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`
+          );
+        }
 
-        release.changesets.push(changeset.id);
-      }
+        if (!release) {
+          release = {
+            name,
+            type,
+            oldVersion: pkg.packageJson.version,
+            changesets: [changeset.id],
+          };
+        } else {
+          if (
+            type === "major" ||
+            ((release.type === "patch" || release.type === "none") &&
+              (type === "minor" || type === "patch"))
+          ) {
+            release.type = type;
+          } // Check whether the bumpType will change
+          // If the bumpType has changed recalc newVersion
+          // push new changeset to releases
+
+          release.changesets.push(changeset.id);
+        }
 
-      releases.set(name, release);
-    });
+        releases.set(name, release);
+      });
   });
   return releases;
 }
@@ -353,16 +398,24 @@ function matchFixedConstraint(releases, packagesByName, config) {
   let updated = false;
 
   for (let fixedPackages of config.fixed) {
-    let releasingFixedPackages = [...releases.values()].filter(release => fixedPackages.includes(release.name) && release.type !== "none");
+    let releasingFixedPackages = [...releases.values()].filter(
+      (release) =>
+        fixedPackages.includes(release.name) && release.type !== "none"
+    );
     if (releasingFixedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingFixedPackages);
-    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(
+      fixedPackages,
+      packagesByName
+    ); // Finally, we update the packages so all of them are on the highest version
 
     for (let pkgName of fixedPackages) {
-      if (shouldSkipPackage.shouldSkipPackage(packagesByName.get(pkgName), {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
+      if (
+        shouldSkipPackage.shouldSkipPackage(packagesByName.get(pkgName), {
+          ignore: config.ignore,
+          allowPrivatePackages: config.privatePackages.version,
+        })
+      ) {
         continue;
       }
 
@@ -374,7 +427,7 @@ function matchFixedConstraint(releases, packagesByName, config) {
           name: pkgName,
           type: highestReleaseType,
           oldVersion: highestVersion,
-          changesets: []
+          changesets: [],
         });
         continue;
       }
@@ -396,7 +449,8 @@ function matchFixedConstraint(releases, packagesByName, config) {
 
 function getPreVersion(version) {
   let parsed = semverParse__default["default"](version);
-  let preVersion = parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
+  let preVersion =
+    parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
 
   if (typeof preVersion !== "number") {
     throw new errors.InternalError("preVersion is not a number");
@@ -412,18 +466,25 @@ function getSnapshotSuffix(template, snapshotParameters) {
     commit: snapshotParameters.commit,
     tag: snapshotParameters.tag,
     timestamp: snapshotRefDate.getTime().toString(),
-    datetime: snapshotRefDate.toISOString().replace(/\.\d{3}Z$/, "").replace(/[^\d]/g, "")
+    datetime: snapshotRefDate
+      .toISOString()
+      .replace(/\.\d{3}Z$/, "")
+      .replace(/[^\d]/g, ""),
   }; // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
   // and the resulting version needs to be composed without a tag.
 
   if (!template) {
-    return [placeholderValues.tag, placeholderValues.datetime].filter(Boolean).join("-");
+    return [placeholderValues.tag, placeholderValues.datetime]
+      .filter(Boolean)
+      .join("-");
   }
 
   const placeholders = Object.keys(placeholderValues);
 
   if (!template.includes(`{tag}`) && placeholderValues.tag !== undefined) {
-    throw new Error(`Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`);
+    throw new Error(
+      `Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`
+    );
   }
 
   return placeholders.reduce((prev, key) => {
@@ -431,7 +492,9 @@ function getSnapshotSuffix(template, snapshotParameters) {
       const value = placeholderValues[key];
 
       if (value === undefined) {
-        throw new Error(`Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`);
+        throw new Error(
+          `Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`
+        );
       }
 
       return value;
@@ -439,7 +502,12 @@ function getSnapshotSuffix(template, snapshotParameters) {
   }, template);
 }
 
-function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuffix) {
+function getSnapshotVersion(
+  release,
+  preInfo,
+  useCalculatedVersion,
+  snapshotSuffix
+) {
   if (release.type === "none") {
     return release.oldVersion;
   }
@@ -453,8 +521,9 @@ function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuff
    * You can set `snapshot.useCalculatedVersion` flag to true to use calculated versions if you don't care about the above problem.
    */
 
-
-  const baseVersion = useCalculatedVersion ? incrementVersion(release, preInfo) : `0.0.0`;
+  const baseVersion = useCalculatedVersion
+    ? incrementVersion(release, preInfo)
+    : `0.0.0`;
   return `${baseVersion}-${snapshotSuffix}`;
 }
 
@@ -466,33 +535,67 @@ function getNewVersion(release, preInfo) {
   return incrementVersion(release, preInfo);
 }
 
-function assembleReleasePlan(changesets, packages, config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
-preState, // snapshot: undefined            ->  not using snaphot
-// snapshot: { tag: undefined }   ->  --snapshot (empty tag)
-// snapshot: { tag: "canary" }    ->  --snapshot canary
-snapshot) {
+function assembleReleasePlan(
+  changesets,
+  packages,
+  config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
+  preState, // snapshot: undefined            ->  not using snaphot
+  // snapshot: { tag: undefined }   ->  --snapshot (empty tag)
+  // snapshot: { tag: "canary" }    ->  --snapshot canary
+  snapshot
+) {
   // TODO: remove `refined*` in the next major version of this package
   // just use `config` and `snapshot` parameters directly, typed as: `config: Config, snapshot?: SnapshotReleaseParameters`
-  const refinedConfig = config.snapshot ? config : _objectSpread(_objectSpread({}, config), {}, {
-    snapshot: {
-      prereleaseTemplate: null,
-      useCalculatedVersion: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.useCalculatedVersionForSnapshots
-    }
-  });
-  const refinedSnapshot = typeof snapshot === "string" ? {
-    tag: snapshot
-  } : typeof snapshot === "boolean" ? {
-    tag: undefined
-  } : snapshot;
-  let packagesByName = new Map(packages.packages.map(x => [x.packageJson.name, x]));
-  const relevantChangesets = getRelevantChangesets(changesets, packagesByName, refinedConfig, preState);
-  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState); // releases is, at this point a list of all packages we are going to releases,
+  const refinedConfig = config.snapshot
+    ? config
+    : _objectSpread(
+        _objectSpread({}, config),
+        {},
+        {
+          snapshot: {
+            prereleaseTemplate: null,
+            useCalculatedVersion:
+              config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
+                .useCalculatedVersionForSnapshots,
+          },
+        }
+      );
+  const refinedSnapshot =
+    typeof snapshot === "string"
+      ? {
+          tag: snapshot,
+        }
+      : typeof snapshot === "boolean"
+      ? {
+          tag: undefined,
+        }
+      : snapshot;
+  let packagesByName = new Map(
+    packages.packages.map((x) => [x.packageJson.name, x])
+  );
+  const relevantChangesets = getRelevantChangesets(
+    changesets,
+    packagesByName,
+    refinedConfig,
+    preState
+  );
+  const preInfo = getPreInfo(
+    changesets,
+    packagesByName,
+    refinedConfig,
+    preState
+  ); // releases is, at this point a list of all packages we are going to releases,
   // flattened down to one release per package, having a reference back to their
   // changesets, and with a calculated new versions
 
-  let releases = flattenReleases(relevantChangesets, packagesByName, refinedConfig);
+  let releases = flattenReleases(
+    relevantChangesets,
+    packagesByName,
+    refinedConfig
+  );
   let dependencyGraph = getDependentsGraph.getDependentsGraph(packages, {
-    bumpVersionsWithWorkspaceProtocolOnly: refinedConfig.bumpVersionsWithWorkspaceProtocolOnly
+    bumpVersionsWithWorkspaceProtocolOnly:
+      refinedConfig.bumpVersionsWithWorkspaceProtocolOnly,
   });
   let releasesValidated = false;
 
@@ -503,15 +606,27 @@ snapshot) {
       packagesByName,
       dependencyGraph,
       preInfo,
-      config: refinedConfig
+      config: refinedConfig,
     }); // `releases` might get mutated here
 
-    let fixedConstraintUpdated = matchFixedConstraint(releases, packagesByName, refinedConfig);
-    let linksUpdated = applyLinks(releases, packagesByName, refinedConfig.linked);
-    releasesValidated = !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
+    let fixedConstraintUpdated = matchFixedConstraint(
+      releases,
+      packagesByName,
+      refinedConfig
+    );
+    let linksUpdated = applyLinks(
+      releases,
+      packagesByName,
+      refinedConfig.linked
+    );
+    releasesValidated =
+      !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
   }
 
-  if ((preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) === "exit") {
+  if (
+    (preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) ===
+    "exit"
+  ) {
     for (let pkg of packages.packages) {
       // If a package had a prerelease, but didn't trigger a version bump in the regular release,
       // we want to give it a patch release.
@@ -524,28 +639,46 @@ snapshot) {
             name: pkg.packageJson.name,
             type: "patch",
             oldVersion: pkg.packageJson.version,
-            changesets: []
+            changesets: [],
           });
-        } else if (existingRelease.type === "none" && !shouldSkipPackage.shouldSkipPackage(pkg, {
-          ignore: refinedConfig.ignore,
-          allowPrivatePackages: refinedConfig.privatePackages.version
-        })) {
+        } else if (
+          existingRelease.type === "none" &&
+          !shouldSkipPackage.shouldSkipPackage(pkg, {
+            ignore: refinedConfig.ignore,
+            allowPrivatePackages: refinedConfig.privatePackages.version,
+          })
+        ) {
           existingRelease.type = "patch";
         }
       }
     }
   } // Caching the snapshot version here and use this if it is snapshot release
 
-
-  const snapshotSuffix = refinedSnapshot && getSnapshotSuffix(refinedConfig.snapshot.prereleaseTemplate, refinedSnapshot);
+  const snapshotSuffix =
+    refinedSnapshot &&
+    getSnapshotSuffix(
+      refinedConfig.snapshot.prereleaseTemplate,
+      refinedSnapshot
+    );
   return {
     changesets: relevantChangesets,
-    releases: [...releases.values()].map(incompleteRelease => {
-      return _objectSpread(_objectSpread({}, incompleteRelease), {}, {
-        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo)
-      });
+    releases: [...releases.values()].map((incompleteRelease) => {
+      return _objectSpread(
+        _objectSpread({}, incompleteRelease),
+        {},
+        {
+          newVersion: snapshotSuffix
+            ? getSnapshotVersion(
+                incompleteRelease,
+                preInfo,
+                refinedConfig.snapshot.useCalculatedVersion,
+                snapshotSuffix
+              )
+            : getNewVersion(incompleteRelease, preInfo),
+        }
+      );
     }),
-    preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state
+    preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state,
   };
 }
 
@@ -557,10 +690,12 @@ function getRelevantChangesets(changesets, packagesByName, config, preState) {
     const notSkippedPackages = [];
 
     for (const release of changeset.releases) {
-      if (shouldSkipPackage.shouldSkipPackage(packagesByName.get(release.name), {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
+      if (
+        shouldSkipPackage.shouldSkipPackage(packagesByName.get(release.name), {
+          ignore: config.ignore,
+          allowPrivatePackages: config.privatePackages.version,
+        })
+      ) {
         skippedPackages.push(release.name);
       } else {
         notSkippedPackages.push(release.name);
@@ -568,13 +703,20 @@ function getRelevantChangesets(changesets, packagesByName, config, preState) {
     }
 
     if (skippedPackages.length > 0 && notSkippedPackages.length > 0) {
-      throw new Error(`Found mixed changeset ${changeset.id}\n` + `Found ignored packages: ${skippedPackages.join(" ")}\n` + `Found not ignored packages: ${notSkippedPackages.join(" ")}\n` + "Mixed changesets that contain both ignored and not ignored packages are not allowed");
+      throw new Error(
+        `Found mixed changeset ${changeset.id}\n` +
+          `Found ignored packages: ${skippedPackages.join(" ")}\n` +
+          `Found not ignored packages: ${notSkippedPackages.join(" ")}\n` +
+          "Mixed changesets that contain both ignored and not ignored packages are not allowed"
+      );
     }
   }
 
   if (preState && preState.mode !== "exit") {
     let usedChangesetIds = new Set(preState.changesets);
-    return changesets.filter(changeset => !usedChangesetIds.has(changeset.id));
+    return changesets.filter(
+      (changeset) => !usedChangesetIds.has(changeset.id)
+    );
   }
 
   return changesets;
@@ -584,7 +726,10 @@ function getHighestPreVersion(packageGroup, packagesByName) {
   let highestPreVersion = 0;
 
   for (let pkg of packageGroup) {
-    highestPreVersion = Math.max(getPreVersion(packagesByName.get(pkg).packageJson.version), highestPreVersion);
+    highestPreVersion = Math.max(
+      getPreVersion(packagesByName.get(pkg).packageJson.version),
+      highestPreVersion
+    );
   }
 
   return highestPreVersion;
@@ -595,23 +740,30 @@ function getPreInfo(changesets, packagesByName, config, preState) {
     return;
   }
 
-  let updatedPreState = _objectSpread(_objectSpread({}, preState), {}, {
-    changesets: changesets.map(changeset => changeset.id),
-    initialVersions: _objectSpread({}, preState.initialVersions)
-  });
+  let updatedPreState = _objectSpread(
+    _objectSpread({}, preState),
+    {},
+    {
+      changesets: changesets.map((changeset) => changeset.id),
+      initialVersions: _objectSpread({}, preState.initialVersions),
+    }
+  );
 
   for (const [, pkg] of packagesByName) {
     if (updatedPreState.initialVersions[pkg.packageJson.name] === undefined) {
-      updatedPreState.initialVersions[pkg.packageJson.name] = pkg.packageJson.version;
+      updatedPreState.initialVersions[pkg.packageJson.name] =
+        pkg.packageJson.version;
     }
   } // Populate preVersion
   // preVersion is the map between package name and its next pre version number.
 
-
   let preVersions = new Map();
 
   for (const [, pkg] of packagesByName) {
-    preVersions.set(pkg.packageJson.name, getPreVersion(pkg.packageJson.version));
+    preVersions.set(
+      pkg.packageJson.name,
+      getPreVersion(pkg.packageJson.version)
+    );
   }
 
   for (let fixedGroup of config.fixed) {
@@ -632,7 +784,7 @@ function getPreInfo(changesets, packagesByName, config, preState) {
 
   return {
     state: updatedPreState,
-    preVersions
+    preVersions,
   };
 }
 
diff --git a/dist/changesets-assemble-release-plan.esm.js b/dist/changesets-assemble-release-plan.esm.js
index f6583cf3f639e1fe4df764a015689dea74127236..a8273d853108d0f72118f9893a4ac7dff0cccb1d 100644
--- a/dist/changesets-assemble-release-plan.esm.js
+++ b/dist/changesets-assemble-release-plan.esm.js
@@ -1,15 +1,17 @@
-import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
-import { InternalError } from '@changesets/errors';
-import { getDependentsGraph } from '@changesets/get-dependents-graph';
-import { shouldSkipPackage } from '@changesets/should-skip-package';
-import semverParse from 'semver/functions/parse';
-import semverGt from 'semver/functions/gt';
-import semverSatisfies from 'semver/functions/satisfies';
-import semverInc from 'semver/functions/inc';
+import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
+import { InternalError } from "@changesets/errors";
+import { getDependentsGraph } from "@changesets/get-dependents-graph";
+import { shouldSkipPackage } from "@changesets/should-skip-package";
+import semverParse from "semver/functions/parse";
+import semverGt from "semver/functions/gt";
+import semverSatisfies from "semver/functions/satisfies";
+import semverInc from "semver/functions/inc";
 
 function getHighestReleaseType(releases) {
   if (releases.length === 0) {
-    throw new Error(`Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`);
+    throw new Error(
+      `Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`
+    );
   }
 
   let highestReleaseType = "none";
@@ -41,11 +43,16 @@ function getCurrentHighestVersion(packageGroup, packagesByName) {
     let pkg = packagesByName.get(pkgName);
 
     if (!pkg) {
-      console.error(`FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`);
+      console.error(
+        `FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`
+      );
       throw new Error(`fatal: could not resolve linked packages`);
     }
 
-    if (highestVersion === undefined || semverGt(pkg.packageJson.version, highestVersion)) {
+    if (
+      highestVersion === undefined ||
+      semverGt(pkg.packageJson.version, highestVersion)
+    ) {
       highestVersion = pkg.packageJson.version;
     }
   }
@@ -71,12 +78,18 @@ function applyLinks(releases, packagesByName, linked) {
 
   for (let linkedPackages of linked) {
     // First we filter down to all the relevant releases for one set of linked packages
-    let releasingLinkedPackages = [...releases.values()].filter(release => linkedPackages.includes(release.name) && release.type !== "none"); // If we proceed any further we do extra work with calculating highestVersion for things that might
+    let releasingLinkedPackages = [...releases.values()].filter(
+      (release) =>
+        linkedPackages.includes(release.name) && release.type !== "none"
+    ); // If we proceed any further we do extra work with calculating highestVersion for things that might
     // not need one, as they only have workspace based packages
 
     if (releasingLinkedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingLinkedPackages);
-    let highestVersion = getCurrentHighestVersion(linkedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(
+      linkedPackages,
+      packagesByName
+    ); // Finally, we update the packages so all of them are on the highest version
 
     for (let linkedPackage of releasingLinkedPackages) {
       if (linkedPackage.type !== highestReleaseType) {
@@ -105,11 +118,12 @@ function incrementVersion(release, preInfo) {
     let preVersion = preInfo.preVersions.get(release.name);
 
     if (preVersion === undefined) {
-      throw new InternalError(`preVersion for ${release.name} does not exist when preState is defined`);
+      throw new InternalError(
+        `preVersion for ${release.name} does not exist when preState is defined`
+      );
     } // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
     // because semver.inc with prereleases is confusing and this seems easier
 
-
     version += `-${preInfo.state.tag}.${preVersion}`;
   }
 
@@ -133,7 +147,7 @@ function determineDependents({
   packagesByName,
   dependencyGraph,
   preInfo,
-  config
+  config,
 }) {
   let updated = false; // NOTE this is intended to be called recursively
 
@@ -147,96 +161,101 @@ function determineDependents({
     const pkgDependents = dependencyGraph.get(nextRelease.name);
 
     if (!pkgDependents) {
-      throw new Error(`Error in determining dependents - could not find package in repository: ${nextRelease.name}`);
+      throw new Error(
+        `Error in determining dependents - could not find package in repository: ${nextRelease.name}`
+      );
     }
 
-    pkgDependents.map(dependent => {
-      let type;
-      const dependentPackage = packagesByName.get(dependent);
-      if (!dependentPackage) throw new Error("Dependency map is incorrect");
-
-      if (shouldSkipPackage(dependentPackage, {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
-        type = "none";
-      } else {
-        const dependencyVersionRanges = getDependencyVersionRanges(dependentPackage.packageJson, nextRelease);
-
-        for (const {
-          depType,
-          versionRange
-        } of dependencyVersionRanges) {
-          if (nextRelease.type === "none") {
-            continue;
-          } else if (shouldBumpMajor({
-            dependent,
-            depType,
-            versionRange,
-            releases,
-            nextRelease,
-            preInfo,
-            onlyUpdatePeerDependentsWhenOutOfRange: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.onlyUpdatePeerDependentsWhenOutOfRange
-          })) {
-            type = "major";
-          } else if ((!releases.has(dependent) || releases.get(dependent).type === "none") && (config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.updateInternalDependents === "always" || !semverSatisfies(incrementVersion(nextRelease, preInfo), versionRange))) {
-            switch (depType) {
-              case "dependencies":
-              case "optionalDependencies":
-              case "peerDependencies":
-                if (type !== "major" && type !== "minor") {
-                  type = "patch";
-                }
+    pkgDependents
+      .map((dependent) => {
+        let type;
+        const dependentPackage = packagesByName.get(dependent);
+        if (!dependentPackage) throw new Error("Dependency map is incorrect");
+
+        if (
+          shouldSkipPackage(dependentPackage, {
+            ignore: config.ignore,
+            allowPrivatePackages: config.privatePackages.version,
+          })
+        ) {
+          type = "none";
+        } else {
+          const dependencyVersionRanges = getDependencyVersionRanges(
+            dependentPackage.packageJson,
+            nextRelease
+          );
+
+          for (const { depType, versionRange } of dependencyVersionRanges) {
+            if (nextRelease.type === "none") {
+              continue;
+            } else if (
+              (!releases.has(dependent) ||
+                releases.get(dependent).type === "none") &&
+              (config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
+                .updateInternalDependents === "always" ||
+                !semverSatisfies(
+                  incrementVersion(nextRelease, preInfo),
+                  versionRange
+                ))
+            ) {
+              switch (depType) {
+                case "dependencies":
+                case "optionalDependencies":
+                case "peerDependencies":
+                  if (type !== "major" && type !== "minor") {
+                    type = "patch";
+                  }
 
-                break;
+                  break;
 
-              case "devDependencies":
-                {
+                case "devDependencies": {
                   // We don't need a version bump if the package is only in the devDependencies of the dependent package
-                  if (type !== "major" && type !== "minor" && type !== "patch") {
+                  if (
+                    type !== "major" &&
+                    type !== "minor" &&
+                    type !== "patch"
+                  ) {
                     type = "none";
                   }
                 }
+              }
             }
           }
         }
-      }
 
-      if (releases.has(dependent) && releases.get(dependent).type === type) {
-        type = undefined;
-      }
+        if (releases.has(dependent) && releases.get(dependent).type === type) {
+          type = undefined;
+        }
 
-      return {
-        name: dependent,
-        type,
-        pkgJSON: dependentPackage.packageJson
-      };
-    }).filter(dependentItem => !!dependentItem.type).forEach(({
-      name,
-      type,
-      pkgJSON
-    }) => {
-      // At this point, we know if we are making a change
-      updated = true;
-      const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
-      // added them here. If we have, we update the existing item instead of pushing it on to search.
-      // It is safe to not add it to pkgsToSearch because it should have already been searched at the
-      // largest possible bump type.
-
-      if (existing && type === "major" && existing.type !== "major") {
-        existing.type = "major";
-        pkgsToSearch.push(existing);
-      } else {
-        let newDependent = {
-          name,
+        return {
+          name: dependent,
           type,
-          oldVersion: pkgJSON.version,
-          changesets: []
+          pkgJSON: dependentPackage.packageJson,
         };
-        pkgsToSearch.push(newDependent);
-        releases.set(name, newDependent);
-      }
-    });
+      })
+      .filter((dependentItem) => !!dependentItem.type)
+      .forEach(({ name, type, pkgJSON }) => {
+        // At this point, we know if we are making a change
+        updated = true;
+        const existing = releases.get(name); // For things that are being given a major bump, we check if we have already
+        // added them here. If we have, we update the existing item instead of pushing it on to search.
+        // It is safe to not add it to pkgsToSearch because it should have already been searched at the
+        // largest possible bump type.
+
+        if (existing && type === "major" && existing.type !== "major") {
+          existing.type = "major";
+          pkgsToSearch.push(existing);
+        } else {
+          let newDependent = {
+            name,
+            type,
+            oldVersion: pkgJSON.version,
+            changesets: [],
+          };
+          pkgsToSearch.push(newDependent);
+          releases.set(name, newDependent);
+        }
+      });
   }
 
   return updated;
@@ -248,27 +267,38 @@ function determineDependents({
 */
 
 function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
-  const DEPENDENCY_TYPES = ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"];
+  const DEPENDENCY_TYPES = [
+    "dependencies",
+    "devDependencies",
+    "peerDependencies",
+    "optionalDependencies",
+  ];
   const dependencyVersionRanges = [];
 
   for (const type of DEPENDENCY_TYPES) {
     var _dependentPkgJSON$typ;
 
-    const versionRange = (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null || _dependentPkgJSON$typ === void 0 ? void 0 : _dependentPkgJSON$typ[dependencyRelease.name];
+    const versionRange =
+      (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null ||
+      _dependentPkgJSON$typ === void 0
+        ? void 0
+        : _dependentPkgJSON$typ[dependencyRelease.name];
     if (!versionRange) continue;
 
     if (versionRange.startsWith("workspace:")) {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange: // intentionally keep other workspace ranges untouched
-        // this has to be fixed but this should only be done when adding appropriate tests
-        versionRange === "workspace:*" ? // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
-        dependencyRelease.oldVersion : versionRange.replace(/^workspace:/, "")
+        // intentionally keep other workspace ranges untouched
+        versionRange:
+          // this has to be fixed but this should only be done when adding appropriate tests
+          versionRange === "workspace:*" // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
+            ? dependencyRelease.oldVersion
+            : versionRange.replace(/^workspace:/, ""),
       });
     } else {
       dependencyVersionRanges.push({
         depType: type,
-        versionRange
+        versionRange,
       });
     }
   }
@@ -283,57 +313,67 @@ function shouldBumpMajor({
   releases,
   nextRelease,
   preInfo,
-  onlyUpdatePeerDependentsWhenOutOfRange
+  onlyUpdatePeerDependentsWhenOutOfRange,
 }) {
   // we check if it is a peerDependency because if it is, our dependent bump type might need to be major.
-  return depType === "peerDependencies" && nextRelease.type !== "none" && nextRelease.type !== "patch" && ( // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
-  // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
-  !onlyUpdatePeerDependentsWhenOutOfRange || !semverSatisfies(incrementVersion(nextRelease, preInfo), versionRange)) && ( // bump major only if the dependent doesn't already has a major release.
-  !releases.has(dependent) || releases.has(dependent) && releases.get(dependent).type !== "major");
+  return (
+    depType === "peerDependencies" &&
+    nextRelease.type !== "none" &&
+    nextRelease.type !== "patch" && // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
+    // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
+    (!onlyUpdatePeerDependentsWhenOutOfRange ||
+      !semverSatisfies(incrementVersion(nextRelease, preInfo), versionRange)) && // bump major only if the dependent doesn't already has a major release.
+    (!releases.has(dependent) ||
+      (releases.has(dependent) && releases.get(dependent).type !== "major"))
+  );
 }
 
 // This function takes in changesets and returns one release per
 function flattenReleases(changesets, packagesByName, config) {
   let releases = new Map();
-  changesets.forEach(changeset => {
+  changesets.forEach((changeset) => {
     changeset.releases // Filter out skipped packages because they should not trigger a release
-    // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
-    .filter(({
-      name
-    }) => !shouldSkipPackage(packagesByName.get(name), {
-      ignore: config.ignore,
-      allowPrivatePackages: config.privatePackages.version
-    })).forEach(({
-      name,
-      type
-    }) => {
-      let release = releases.get(name);
-      let pkg = packagesByName.get(name);
-
-      if (!pkg) {
-        throw new Error(`"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`);
-      }
-
-      if (!release) {
-        release = {
-          name,
-          type,
-          oldVersion: pkg.packageJson.version,
-          changesets: [changeset.id]
-        };
-      } else {
-        if (type === "major" || (release.type === "patch" || release.type === "none") && (type === "minor" || type === "patch")) {
-          release.type = type;
-        } // Check whether the bumpType will change
-        // If the bumpType has changed recalc newVersion
-        // push new changeset to releases
-
+      // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
+      .filter(
+        ({ name }) =>
+          !shouldSkipPackage(packagesByName.get(name), {
+            ignore: config.ignore,
+            allowPrivatePackages: config.privatePackages.version,
+          })
+      )
+      .forEach(({ name, type }) => {
+        let release = releases.get(name);
+        let pkg = packagesByName.get(name);
+
+        if (!pkg) {
+          throw new Error(
+            `"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`
+          );
+        }
 
-        release.changesets.push(changeset.id);
-      }
+        if (!release) {
+          release = {
+            name,
+            type,
+            oldVersion: pkg.packageJson.version,
+            changesets: [changeset.id],
+          };
+        } else {
+          if (
+            type === "major" ||
+            ((release.type === "patch" || release.type === "none") &&
+              (type === "minor" || type === "patch"))
+          ) {
+            release.type = type;
+          } // Check whether the bumpType will change
+          // If the bumpType has changed recalc newVersion
+          // push new changeset to releases
+
+          release.changesets.push(changeset.id);
+        }
 
-      releases.set(name, release);
-    });
+        releases.set(name, release);
+      });
   });
   return releases;
 }
@@ -342,16 +382,24 @@ function matchFixedConstraint(releases, packagesByName, config) {
   let updated = false;
 
   for (let fixedPackages of config.fixed) {
-    let releasingFixedPackages = [...releases.values()].filter(release => fixedPackages.includes(release.name) && release.type !== "none");
+    let releasingFixedPackages = [...releases.values()].filter(
+      (release) =>
+        fixedPackages.includes(release.name) && release.type !== "none"
+    );
     if (releasingFixedPackages.length === 0) continue;
     let highestReleaseType = getHighestReleaseType(releasingFixedPackages);
-    let highestVersion = getCurrentHighestVersion(fixedPackages, packagesByName); // Finally, we update the packages so all of them are on the highest version
+    let highestVersion = getCurrentHighestVersion(
+      fixedPackages,
+      packagesByName
+    ); // Finally, we update the packages so all of them are on the highest version
 
     for (let pkgName of fixedPackages) {
-      if (shouldSkipPackage(packagesByName.get(pkgName), {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
+      if (
+        shouldSkipPackage(packagesByName.get(pkgName), {
+          ignore: config.ignore,
+          allowPrivatePackages: config.privatePackages.version,
+        })
+      ) {
         continue;
       }
 
@@ -363,7 +411,7 @@ function matchFixedConstraint(releases, packagesByName, config) {
           name: pkgName,
           type: highestReleaseType,
           oldVersion: highestVersion,
-          changesets: []
+          changesets: [],
         });
         continue;
       }
@@ -385,7 +433,8 @@ function matchFixedConstraint(releases, packagesByName, config) {
 
 function getPreVersion(version) {
   let parsed = semverParse(version);
-  let preVersion = parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
+  let preVersion =
+    parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1];
 
   if (typeof preVersion !== "number") {
     throw new InternalError("preVersion is not a number");
@@ -401,18 +450,25 @@ function getSnapshotSuffix(template, snapshotParameters) {
     commit: snapshotParameters.commit,
     tag: snapshotParameters.tag,
     timestamp: snapshotRefDate.getTime().toString(),
-    datetime: snapshotRefDate.toISOString().replace(/\.\d{3}Z$/, "").replace(/[^\d]/g, "")
+    datetime: snapshotRefDate
+      .toISOString()
+      .replace(/\.\d{3}Z$/, "")
+      .replace(/[^\d]/g, ""),
   }; // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
   // and the resulting version needs to be composed without a tag.
 
   if (!template) {
-    return [placeholderValues.tag, placeholderValues.datetime].filter(Boolean).join("-");
+    return [placeholderValues.tag, placeholderValues.datetime]
+      .filter(Boolean)
+      .join("-");
   }
 
   const placeholders = Object.keys(placeholderValues);
 
   if (!template.includes(`{tag}`) && placeholderValues.tag !== undefined) {
-    throw new Error(`Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`);
+    throw new Error(
+      `Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`
+    );
   }
 
   return placeholders.reduce((prev, key) => {
@@ -420,7 +476,9 @@ function getSnapshotSuffix(template, snapshotParameters) {
       const value = placeholderValues[key];
 
       if (value === undefined) {
-        throw new Error(`Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`);
+        throw new Error(
+          `Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`
+        );
       }
 
       return value;
@@ -428,7 +486,12 @@ function getSnapshotSuffix(template, snapshotParameters) {
   }, template);
 }
 
-function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuffix) {
+function getSnapshotVersion(
+  release,
+  preInfo,
+  useCalculatedVersion,
+  snapshotSuffix
+) {
   if (release.type === "none") {
     return release.oldVersion;
   }
@@ -442,8 +505,9 @@ function getSnapshotVersion(release, preInfo, useCalculatedVersion, snapshotSuff
    * You can set `snapshot.useCalculatedVersion` flag to true to use calculated versions if you don't care about the above problem.
    */
 
-
-  const baseVersion = useCalculatedVersion ? incrementVersion(release, preInfo) : `0.0.0`;
+  const baseVersion = useCalculatedVersion
+    ? incrementVersion(release, preInfo)
+    : `0.0.0`;
   return `${baseVersion}-${snapshotSuffix}`;
 }
 
@@ -455,33 +519,67 @@ function getNewVersion(release, preInfo) {
   return incrementVersion(release, preInfo);
 }
 
-function assembleReleasePlan(changesets, packages, config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
-preState, // snapshot: undefined            ->  not using snaphot
-// snapshot: { tag: undefined }   ->  --snapshot (empty tag)
-// snapshot: { tag: "canary" }    ->  --snapshot canary
-snapshot) {
+function assembleReleasePlan(
+  changesets,
+  packages,
+  config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
+  preState, // snapshot: undefined            ->  not using snaphot
+  // snapshot: { tag: undefined }   ->  --snapshot (empty tag)
+  // snapshot: { tag: "canary" }    ->  --snapshot canary
+  snapshot
+) {
   // TODO: remove `refined*` in the next major version of this package
   // just use `config` and `snapshot` parameters directly, typed as: `config: Config, snapshot?: SnapshotReleaseParameters`
-  const refinedConfig = config.snapshot ? config : _objectSpread(_objectSpread({}, config), {}, {
-    snapshot: {
-      prereleaseTemplate: null,
-      useCalculatedVersion: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.useCalculatedVersionForSnapshots
-    }
-  });
-  const refinedSnapshot = typeof snapshot === "string" ? {
-    tag: snapshot
-  } : typeof snapshot === "boolean" ? {
-    tag: undefined
-  } : snapshot;
-  let packagesByName = new Map(packages.packages.map(x => [x.packageJson.name, x]));
-  const relevantChangesets = getRelevantChangesets(changesets, packagesByName, refinedConfig, preState);
-  const preInfo = getPreInfo(changesets, packagesByName, refinedConfig, preState); // releases is, at this point a list of all packages we are going to releases,
+  const refinedConfig = config.snapshot
+    ? config
+    : _objectSpread(
+        _objectSpread({}, config),
+        {},
+        {
+          snapshot: {
+            prereleaseTemplate: null,
+            useCalculatedVersion:
+              config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
+                .useCalculatedVersionForSnapshots,
+          },
+        }
+      );
+  const refinedSnapshot =
+    typeof snapshot === "string"
+      ? {
+          tag: snapshot,
+        }
+      : typeof snapshot === "boolean"
+      ? {
+          tag: undefined,
+        }
+      : snapshot;
+  let packagesByName = new Map(
+    packages.packages.map((x) => [x.packageJson.name, x])
+  );
+  const relevantChangesets = getRelevantChangesets(
+    changesets,
+    packagesByName,
+    refinedConfig,
+    preState
+  );
+  const preInfo = getPreInfo(
+    changesets,
+    packagesByName,
+    refinedConfig,
+    preState
+  ); // releases is, at this point a list of all packages we are going to releases,
   // flattened down to one release per package, having a reference back to their
   // changesets, and with a calculated new versions
 
-  let releases = flattenReleases(relevantChangesets, packagesByName, refinedConfig);
+  let releases = flattenReleases(
+    relevantChangesets,
+    packagesByName,
+    refinedConfig
+  );
   let dependencyGraph = getDependentsGraph(packages, {
-    bumpVersionsWithWorkspaceProtocolOnly: refinedConfig.bumpVersionsWithWorkspaceProtocolOnly
+    bumpVersionsWithWorkspaceProtocolOnly:
+      refinedConfig.bumpVersionsWithWorkspaceProtocolOnly,
   });
   let releasesValidated = false;
 
@@ -492,15 +590,27 @@ snapshot) {
       packagesByName,
       dependencyGraph,
       preInfo,
-      config: refinedConfig
+      config: refinedConfig,
     }); // `releases` might get mutated here
 
-    let fixedConstraintUpdated = matchFixedConstraint(releases, packagesByName, refinedConfig);
-    let linksUpdated = applyLinks(releases, packagesByName, refinedConfig.linked);
-    releasesValidated = !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
+    let fixedConstraintUpdated = matchFixedConstraint(
+      releases,
+      packagesByName,
+      refinedConfig
+    );
+    let linksUpdated = applyLinks(
+      releases,
+      packagesByName,
+      refinedConfig.linked
+    );
+    releasesValidated =
+      !linksUpdated && !dependentAdded && !fixedConstraintUpdated;
   }
 
-  if ((preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) === "exit") {
+  if (
+    (preInfo === null || preInfo === void 0 ? void 0 : preInfo.state.mode) ===
+    "exit"
+  ) {
     for (let pkg of packages.packages) {
       // If a package had a prerelease, but didn't trigger a version bump in the regular release,
       // we want to give it a patch release.
@@ -513,28 +623,46 @@ snapshot) {
             name: pkg.packageJson.name,
             type: "patch",
             oldVersion: pkg.packageJson.version,
-            changesets: []
+            changesets: [],
           });
-        } else if (existingRelease.type === "none" && !shouldSkipPackage(pkg, {
-          ignore: refinedConfig.ignore,
-          allowPrivatePackages: refinedConfig.privatePackages.version
-        })) {
+        } else if (
+          existingRelease.type === "none" &&
+          !shouldSkipPackage(pkg, {
+            ignore: refinedConfig.ignore,
+            allowPrivatePackages: refinedConfig.privatePackages.version,
+          })
+        ) {
           existingRelease.type = "patch";
         }
       }
     }
   } // Caching the snapshot version here and use this if it is snapshot release
 
-
-  const snapshotSuffix = refinedSnapshot && getSnapshotSuffix(refinedConfig.snapshot.prereleaseTemplate, refinedSnapshot);
+  const snapshotSuffix =
+    refinedSnapshot &&
+    getSnapshotSuffix(
+      refinedConfig.snapshot.prereleaseTemplate,
+      refinedSnapshot
+    );
   return {
     changesets: relevantChangesets,
-    releases: [...releases.values()].map(incompleteRelease => {
-      return _objectSpread(_objectSpread({}, incompleteRelease), {}, {
-        newVersion: snapshotSuffix ? getSnapshotVersion(incompleteRelease, preInfo, refinedConfig.snapshot.useCalculatedVersion, snapshotSuffix) : getNewVersion(incompleteRelease, preInfo)
-      });
+    releases: [...releases.values()].map((incompleteRelease) => {
+      return _objectSpread(
+        _objectSpread({}, incompleteRelease),
+        {},
+        {
+          newVersion: snapshotSuffix
+            ? getSnapshotVersion(
+                incompleteRelease,
+                preInfo,
+                refinedConfig.snapshot.useCalculatedVersion,
+                snapshotSuffix
+              )
+            : getNewVersion(incompleteRelease, preInfo),
+        }
+      );
     }),
-    preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state
+    preState: preInfo === null || preInfo === void 0 ? void 0 : preInfo.state,
   };
 }
 
@@ -546,10 +674,12 @@ function getRelevantChangesets(changesets, packagesByName, config, preState) {
     const notSkippedPackages = [];
 
     for (const release of changeset.releases) {
-      if (shouldSkipPackage(packagesByName.get(release.name), {
-        ignore: config.ignore,
-        allowPrivatePackages: config.privatePackages.version
-      })) {
+      if (
+        shouldSkipPackage(packagesByName.get(release.name), {
+          ignore: config.ignore,
+          allowPrivatePackages: config.privatePackages.version,
+        })
+      ) {
         skippedPackages.push(release.name);
       } else {
         notSkippedPackages.push(release.name);
@@ -557,13 +687,20 @@ function getRelevantChangesets(changesets, packagesByName, config, preState) {
     }
 
     if (skippedPackages.length > 0 && notSkippedPackages.length > 0) {
-      throw new Error(`Found mixed changeset ${changeset.id}\n` + `Found ignored packages: ${skippedPackages.join(" ")}\n` + `Found not ignored packages: ${notSkippedPackages.join(" ")}\n` + "Mixed changesets that contain both ignored and not ignored packages are not allowed");
+      throw new Error(
+        `Found mixed changeset ${changeset.id}\n` +
+          `Found ignored packages: ${skippedPackages.join(" ")}\n` +
+          `Found not ignored packages: ${notSkippedPackages.join(" ")}\n` +
+          "Mixed changesets that contain both ignored and not ignored packages are not allowed"
+      );
     }
   }
 
   if (preState && preState.mode !== "exit") {
     let usedChangesetIds = new Set(preState.changesets);
-    return changesets.filter(changeset => !usedChangesetIds.has(changeset.id));
+    return changesets.filter(
+      (changeset) => !usedChangesetIds.has(changeset.id)
+    );
   }
 
   return changesets;
@@ -573,7 +710,10 @@ function getHighestPreVersion(packageGroup, packagesByName) {
   let highestPreVersion = 0;
 
   for (let pkg of packageGroup) {
-    highestPreVersion = Math.max(getPreVersion(packagesByName.get(pkg).packageJson.version), highestPreVersion);
+    highestPreVersion = Math.max(
+      getPreVersion(packagesByName.get(pkg).packageJson.version),
+      highestPreVersion
+    );
   }
 
   return highestPreVersion;
@@ -584,23 +724,30 @@ function getPreInfo(changesets, packagesByName, config, preState) {
     return;
   }
 
-  let updatedPreState = _objectSpread(_objectSpread({}, preState), {}, {
-    changesets: changesets.map(changeset => changeset.id),
-    initialVersions: _objectSpread({}, preState.initialVersions)
-  });
+  let updatedPreState = _objectSpread(
+    _objectSpread({}, preState),
+    {},
+    {
+      changesets: changesets.map((changeset) => changeset.id),
+      initialVersions: _objectSpread({}, preState.initialVersions),
+    }
+  );
 
   for (const [, pkg] of packagesByName) {
     if (updatedPreState.initialVersions[pkg.packageJson.name] === undefined) {
-      updatedPreState.initialVersions[pkg.packageJson.name] = pkg.packageJson.version;
+      updatedPreState.initialVersions[pkg.packageJson.name] =
+        pkg.packageJson.version;
     }
   } // Populate preVersion
   // preVersion is the map between package name and its next pre version number.
 
-
   let preVersions = new Map();
 
   for (const [, pkg] of packagesByName) {
-    preVersions.set(pkg.packageJson.name, getPreVersion(pkg.packageJson.version));
+    preVersions.set(
+      pkg.packageJson.name,
+      getPreVersion(pkg.packageJson.version)
+    );
   }
 
   for (let fixedGroup of config.fixed) {
@@ -621,7 +768,7 @@ function getPreInfo(changesets, packagesByName, config, preState) {
 
   return {
     state: updatedPreState,
-    preVersions
+    preVersions,
   };
 }
 
