import * as S from "@effect/schema/Schema";
import { secretbox } from "@noble/ciphers/salsa";
import { concatBytes } from "@noble/ciphers/utils";
import { hmac } from "@noble/hashes/hmac";
import { sha512 } from "@noble/hashes/sha512";
import { randomBytes } from "@noble/hashes/utils";
import * as bip39 from "@scure/bip39";
import { wordlist } from "@scure/bip39/wordlists/english";
import * as Brand from "effect/Brand";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import { Id } from "./Model.js";

/**
 * Mnemonic is a password generated by Evolu in BIP39 format.
 *
 * A mnemonic, also known as a "seed phrase," is a set of 12 words in a specific
 * order chosen from a predefined list. The purpose of the BIP39 mnemonic is to
 * provide a human-readable way of storing a private key.
 */
export type Mnemonic = string & Brand.Brand<"Mnemonic">;

/**
 * Mnemonic is a password generated by Evolu in BIP39 format.
 *
 * A mnemonic, also known as a "seed phrase," is a set of 12 words in a specific
 * order chosen from a predefined list. The purpose of the BIP39 mnemonic is to
 * provide a human-readable way of storing a private key.
 */
export const createMnemonic = (): Mnemonic =>
  bip39.generateMnemonic(wordlist, 128) as Mnemonic;

/** Parse a string to {@link Mnemonic}. */
export const parseMnemonic = (
  mnemonic: string,
): Effect.Effect<Mnemonic, InvalidMnemonicError> => {
  const mnemonicTrimmed = mnemonic.trim();
  return bip39.validateMnemonic(mnemonicTrimmed, wordlist)
    ? Effect.succeed(mnemonicTrimmed as Mnemonic)
    : Effect.fail<InvalidMnemonicError>({
        _tag: "InvalidMnemonicError",
      });
};

export interface InvalidMnemonicError {
  readonly _tag: "InvalidMnemonicError";
}

export const mnemonicToSeed = (mnemonic: Mnemonic): Uint8Array =>
  bip39.mnemonicToSeedSync(mnemonic);

export class NanoIdGenerator extends Context.Tag("NanoIdGenerator")<
  NanoIdGenerator,
  {
    readonly nanoid: Effect.Effect<NanoId>;
    readonly nodeId: Effect.Effect<NodeId>;
    readonly rowId: Effect.Effect<Id>;
  }
>() {}

export const createNanoIdGeneratorLive = (
  customAlphabet: (
    alphabet: string,
    defaultSize?: number | undefined,
  ) => (size?: number | undefined) => string,
  nanoid: (size?: number) => string,
): Layer.Layer<NanoIdGenerator, never, never> => {
  const nanoidForNodeId = customAlphabet("0123456789abcdef", 16);
  return Layer.succeed(
    NanoIdGenerator,
    NanoIdGenerator.of({
      nanoid: Effect.sync(() => nanoid() as NanoId),
      nodeId: Effect.sync(() => nanoidForNodeId() as NodeId),
      rowId: Effect.sync(() => nanoid() as Id),
    }),
  );
};

export type NanoId = string & Brand.Brand<"NanoId">;

export const NodeId = S.String.pipe(
  S.pattern(/^[\w-]{16}$/),
  S.brand("NodeId"),
);
export type NodeId = typeof NodeId.Type;

// SLIP-21 implementation
// https://github.com/satoshilabs/slips/blob/master/slip-0021.md
export const slip21Derive = (
  seed: Uint8Array,
  path: ReadonlyArray<string>,
): Effect.Effect<Uint8Array> =>
  Effect.sync(() => {
    let m = hmac(sha512, "Symmetric key seed", seed);
    for (let i = 0; i < path.length; i++) {
      const p = new TextEncoder().encode(path[i]);
      const e = new Uint8Array(p.byteLength + 1);
      e[0] = 0;
      e.set(p, 1);
      m = hmac(sha512, m.slice(0, 32), e);
    }
    return m.slice(32, 64);
  });

export class SecretBox extends Context.Tag("SecretBox")<
  SecretBox,
  {
    readonly seal: (
      key: Uint8Array,
      plaintext: Uint8Array,
    ) => Effect.Effect<Uint8Array>;

    readonly open: (
      key: Uint8Array,
      ciphertext: Uint8Array,
    ) => Effect.Effect<Uint8Array>;
  }
>() {
  static Live = Layer.succeed(
    SecretBox,
    SecretBox.of({
      seal: (key, plaintext) =>
        Effect.sync(() => {
          const nonce = randomBytes(24);
          const ciphertext = secretbox(key, nonce).seal(plaintext);
          return concatBytes(nonce, ciphertext);
        }),
      open: (key, ciphertext) =>
        Effect.sync(() => {
          const nonce = ciphertext.subarray(0, 24);
          const ciphertextWithoutNonce = ciphertext.subarray(24);
          return secretbox(key, nonce).open(ciphertextWithoutNonce);
        }),
    }),
  );
}
