import { Brand, Context, Effect } from "effect";
import { NodeId } from "./Timestamp.js";
import type { hmac } from "@noble/hashes/hmac";
import { sha512 } from "@noble/hashes/sha512";

/**
 * Mnemonic is a password generated by Evolu in BIP39 format.
 *
 * A mnemonic, also known as a "seed phrase," is a set of 12 words in a
 * specific order chosen from a predefined list. The purpose of the BIP39
 * mnemonic is to provide a human-readable way of storing a private key.
 */
export type Mnemonic = string & Brand.Brand<"Mnemonic">;

export interface MnemonicService {
  readonly make: Effect.Effect<never, never, Mnemonic>;
  readonly mnemonicToSeed: (
    mnemonic: Mnemonic
  ) => Effect.Effect<never, never, Uint8Array>;
}
export const MnemonicService = Context.Tag<MnemonicService>();

export interface HmacService {
  readonly make: Effect.Effect<never, never, typeof hmac>;
}
export const HmacService = Context.Tag<HmacService>();

export interface Sha512Service {
  readonly make: Effect.Effect<never, never, typeof sha512>;
}
export const Sha512Service = Context.Tag<Sha512Service>();

/**
 * SLIP-21 implementation
 * https://github.com/satoshilabs/slips/blob/master/slip-0021.md
 */
export const slip21Derive = (
  seed: Uint8Array,
  path: string[]
): Effect.Effect<HmacService | Sha512Service, never, Uint8Array> =>
  Effect.all([HmacService, Sha512Service]).pipe(
    Effect.flatMap(([HmacService, Sha512Service]) =>
      Effect.all([HmacService.make, Sha512Service.make], {
        concurrency: "unbounded",
      })
    ),
    Effect.map(([hmac, sha512]) => {
      let m = hmac(sha512, "Symmetric key seed", seed);
      for (let i = 0; i < path.length; i++) {
        const p = new TextEncoder().encode(path[i]);
        const e = new Uint8Array(p.byteLength + 1);
        e[0] = 0;
        e.set(p, 1);
        m = hmac(sha512, m.slice(0, 32), e);
      }
      return m.slice(32, 64);
    })
  );

// export const customAlphabetForNodeId = "0123456789abcdef";

// export interface Crypto {
//   readonly makeNodeId: Effect.Effect<never, never, NodeId>;

//   readonly makeMnemonic: Effect.Effect<never, never, Mnemonic>;
//   // TODO: parseMnemonic

//   readonly mnemonicToSeed: (
//     mnemonic: Mnemonic
//   ) => Effect.Effect<never, never, Uint8Array>;

//   readonly hmac: Effect.Effect<never, never, typeof hmac>;

//   readonly sha512: Effect.Effect<never, never, typeof sha512>;
// }

// export const Crypto = Context.Tag<Crypto>();
