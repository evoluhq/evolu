import * as Schema from "@effect/schema/Schema";
import type { hmac } from "@noble/hashes/hmac";
import type { sha512 } from "@noble/hashes/sha512";
import { Brand, Context, Effect, Layer } from "effect";

export interface Bip39 {
  readonly make: Effect.Effect<never, never, Mnemonic>;

  readonly toSeed: (
    mnemonic: Mnemonic
  ) => Effect.Effect<never, never, Uint8Array>;

  readonly parse: (
    mnemonic: string
  ) => Effect.Effect<never, InvalidMnemonicError, Mnemonic>;
}

export const Bip39 = Context.Tag<Bip39>("evolu/Bip39");

export interface InvalidMnemonicError {
  readonly _tag: "InvalidMnemonicError";
}

/**
 * Mnemonic is a password generated by Evolu in BIP39 format.
 *
 * A mnemonic, also known as a "seed phrase," is a set of 12 words in a
 * specific order chosen from a predefined list. The purpose of the BIP39
 * mnemonic is to provide a human-readable way of storing a private key.
 */
export type Mnemonic = string & Brand.Brand<"Mnemonic">;

export type Hmac = typeof hmac;

export const Hmac = Context.Tag<Hmac>("evolu/Hmac");

export type Sha512 = typeof sha512;

export const Sha512 = Context.Tag<Sha512>("evolu/Sha512");

/**
 * SLIP-21 implementation
 * https://github.com/satoshilabs/slips/blob/master/slip-0021.md
 */
export interface Slip21 {
  readonly derive: (
    seed: Uint8Array,
    path: string[]
  ) => Effect.Effect<never, never, Uint8Array>;
}

export const Slip21 = Context.Tag<Slip21>("evolu/Slip21");

export const Slip21Live = Layer.effect(
  Slip21,
  Effect.gen(function* (_) {
    const hmac = yield* _(Hmac);
    const sha512 = yield* _(Sha512);

    const derive: Slip21["derive"] = (seed, path) =>
      Effect.sync(() => {
        let m = hmac(sha512, "Symmetric key seed", seed);
        for (let i = 0; i < path.length; i++) {
          const p = new TextEncoder().encode(path[i]);
          const e = new Uint8Array(p.byteLength + 1);
          e[0] = 0;
          e.set(p, 1);
          m = hmac(sha512, m.slice(0, 32), e);
        }
        return m.slice(32, 64);
      });

    return { derive };
  })
);

export interface NanoId {
  readonly nanoid: Effect.Effect<never, never, string>;
  readonly nanoidAsNodeId: Effect.Effect<never, never, NodeId>;
}

export const NanoId = Context.Tag<NanoId>("evolu/NanoId");

export const NodeId: Schema.BrandSchema<
  string,
  string & Brand.Brand<"NodeId">
> = Schema.string.pipe(Schema.pattern(/^[\w-]{16}$/), Schema.brand("NodeId"));
export type NodeId = Schema.To<typeof NodeId>;

export const customAlphabetForNodeId = "0123456789abcdef";

export interface AesGcm {
  readonly encrypt: (
    sharedKey: Uint8Array,
    plaintext: Uint8Array
  ) => Effect.Effect<never, never, Uint8Array>;

  readonly decrypt: (
    sharedKey: Uint8Array,
    ciphertext: Uint8Array
  ) => Effect.Effect<never, never, Uint8Array>;
}

export const AesGcm = Context.Tag<AesGcm>("evolu/AesGcm");
