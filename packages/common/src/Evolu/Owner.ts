/* eslint-disable jsdoc/no-undefined-types */
/**
 * Evolu Owner - Data Ownership and Collaboration
 *
 * An {@link Owner} is an entity that represents ownership of data in Evolu. It
 * consists of cryptographic keys derived from a {@link Mnemonic} via SLIP-21:
 *
 * - **{@link OwnerId}**: Globally unique public identifier
 * - **{@link EncryptionKey}**: Symmetric encryption key for data protection
 * - **{@link WriteKey}**: Authentication token for write operations
 *
 * Every Evolu app has at least one owner, the {@link AppOwner}. There are
 * several owner variants for different use cases:
 *
 * **{@link ShardOwner}**: Derived from {@link AppOwner} for partitioning data and
 * selective synchronization using {@link createShardOwner}
 *
 * **{@link SharedOwner}**: Created for collaboration with write access, not
 * meant to be shared directly
 *
 * **{@link SharedReadonlyOwner}**: Read-only version for safe data sharing,
 * created from {@link SharedOwner} using {@link createSharedReadonlyOwner}
 *
 * Owners are designed for data synchronization and backup. Authentication
 * systems built on public/private key cryptography use these primitives. This
 * design ensures Evolu Relay knows as little as possible - it only sees
 * Timestamp, OwnerId, and EncryptedDbChange.
 *
 * @module
 */

import { NonEmptyReadonlyArray } from "../Array.js";
import {
  CreateMnemonicDep,
  CreateRandomBytesDep,
  createSlip21,
  createSlip21Id,
  EncryptionKey,
  MnemonicSeed,
  mnemonicToMnemonicSeed,
} from "../Crypto.js";
import {
  Base64Url,
  brand,
  Id,
  length,
  Mnemonic,
  NonNegativeInt,
  Uint8Array,
} from "../Type.js";

/**
 * Represents ownership of data in Evolu. Created from a {@link Mnemonic} via
 * SLIP-21 key derivation using {@link createOwner}, providing cryptographic keys
 * for data access and authentication.
 *
 * - {@link OwnerId}: Globally unique public identifier
 * - {@link EncryptionKey}: Symmetric encryption key for data protection
 * - {@link WriteKey}: Authentication token for write operations (rotatable)
 */
export interface Owner {
  readonly id: OwnerId;
  readonly encryptionKey: EncryptionKey;
  readonly writeKey: WriteKey;
}

/**
 * The unique identifier of {@link Owner} derived from the {@link Mnemonic}.
 *
 * This branded {@link Id} type, generated by {@link createSlip21Id}, is a
 * 21-character {@link Base64Url} string (126 bits of entropy), providing a
 * compact, shareable, and secure identifier for UI use, tied to the owner's
 * mnemonic and derivation path.
 */
export const OwnerId = brand("OwnerId", Id);
export type OwnerId = typeof OwnerId.Type;

export const writeKeyLength = 16 as NonNegativeInt;

/**
 * A secure token proving that the initiator can write changes. Derived from a
 * mnemonic or randomly generated via {@link createWriteKey}. It is rotatable.
 */
export const WriteKey = brand("WriteKey", length(writeKeyLength)(Uint8Array));
export type WriteKey = typeof WriteKey.Type;

/** Creates a randomly generated {@link WriteKey}. */
export const createWriteKey = (deps: CreateRandomBytesDep): WriteKey =>
  deps.createRandomBytes(16) as unknown as WriteKey;

/** Creates an {@link Owner} from a {@link Mnemonic} using SLIP-21 key derivation. */
export const createOwner = (mnemonic: Mnemonic): Owner => {
  const seed = mnemonicToMnemonicSeed(mnemonic);
  return createOwnerFromMnemonicSeed(seed);
};

/**
 * Creates an {@link Owner} from a {@link MnemonicSeed} using SLIP-21 key
 * derivation.
 */
export const createOwnerFromMnemonicSeed = (seed: MnemonicSeed): Owner => ({
  id: createSlip21Id(seed, ["Evolu", "Owner Id"]) as OwnerId,

  encryptionKey: createSlip21(seed, [
    "Evolu",
    "Encryption Key",
  ]) as EncryptionKey,

  writeKey: createSlip21(seed, ["Evolu", "Write Key"]).slice(0, 16) as WriteKey,
});

/**
 * The owner representing app data. Can be created from a {@link Mnemonic} or
 * from external keys when the mnemonic should not be shared with the Evolu
 * app.
 */
export interface AppOwner extends Owner {
  readonly type: "AppOwner";

  /**
   * The mnemonic that was used to derive the AppOwner keys. Optional when the
   * AppOwner is created from external keys to avoid sharing the mnemonic with
   * the Evolu app.
   */
  readonly mnemonic?: Mnemonic | null;
}

export const createAppOwner = (mnemonic: Mnemonic): AppOwner => ({
  type: "AppOwner",
  mnemonic,
  ...createOwner(mnemonic),
});

/**
 * Owner for sharding app data. Allows partitioning of database changes for
 * selective synchronization.
 */
export interface ShardOwner extends Owner {
  readonly type: "ShardOwner";
}

/**
 * Creates a {@link ShardOwner} derived from an {@link AppOwner} using the
 * specified path.
 *
 * ### Example
 *
 * ```ts
 * const contactsShard = createShardOwner(appOwner, ["contacts"]);
 * const projectShard = createShardOwner(appOwner, [
 *   "projects",
 *   "project-1",
 * ]);
 * ```
 */
export const createShardOwner = (
  appOwner: AppOwner,
  path: NonEmptyReadonlyArray<string>,
): ShardOwner => {
  /**
   * The shardSeed is never shared or persisted, only used for SLIP-21
   * derivation to create shard-specific keys.
   */
  const shardSeed = createSlip21(
    appOwner.encryptionKey as unknown as MnemonicSeed,
    path,
  ) as MnemonicSeed;

  return {
    type: "ShardOwner",
    ...createOwnerFromMnemonicSeed(shardSeed),
  };
};

/**
 * Owner for collaborative data with write access. Created by a user for their
 * own use, not meant to be shared directly. To share data, use
 * {@link createSharedReadonlyOwner} to create a {@link SharedReadonlyOwner} for
 * read-only access.
 */
export interface SharedOwner extends Owner {
  readonly type: "SharedOwner";
  readonly mnemonic: Mnemonic;
}

/** Creates a {@link SharedOwner} with a freshly generated {@link Mnemonic}. */
export const createSharedOwner = (deps: CreateMnemonicDep): SharedOwner => {
  const mnemonic = deps.createMnemonic();
  return {
    type: "SharedOwner",
    mnemonic,
    ...createOwner(mnemonic),
  };
};

/**
 * Read-only version of a {@link SharedOwner} for data sharing. Contains only the
 * {@link OwnerId} and {@link EncryptionKey} needed for others to read the shared
 * data without write access.
 */
export interface SharedReadonlyOwner {
  readonly type: "SharedReadonlyOwner";
  readonly id: OwnerId;
  readonly encryptionKey: EncryptionKey;
}

/** Creates a {@link SharedReadonlyOwner} from a {@link SharedOwner}. */
export const createSharedReadonlyOwner = (
  sharedOwner: SharedOwner,
): SharedReadonlyOwner => ({
  type: "SharedReadonlyOwner",
  id: sharedOwner.id,
  encryptionKey: sharedOwner.encryptionKey,
});

/**
 * Rotates the {@link WriteKey} for an {@link AppOwner}, {@link ShardOwner}, or
 * {@link SharedOwner}, returning a new instance with the updated key.
 */
export const rotateWriteKey = <T extends AppOwner | ShardOwner | SharedOwner>(
  owner: T,
  newWriteKey: WriteKey,
): T => {
  return {
    ...owner,
    writeKey: newWriteKey,
  } as T;
};
