import * as Kysely from "kysely";
import { Mnemonic } from "../packages/evolu-common/src/Crypto";
import { pipe, ReadonlyRecord, Effect } from "effect";
import * as prettier from "prettier";
import fs from "fs";

/**
 * Evolu internal SQL queries are statically generated to reduce bundle size.
 * Kysely in Web Worker can't be shared with Kysely used in the main thread for
 * createQuery.
 */

// https://kysely.dev/docs/recipes/splitting-query-building-and-execution
const db = new Kysely.Kysely<Database>({
  dialect: {
    createAdapter: () => new Kysely.SqliteAdapter(),
    createDriver: () => new Kysely.DummyDriver(),
    createIntrospector() {
      throw "Not implemeneted";
    },
    createQueryCompiler: () => new Kysely.SqliteQueryCompiler(),
  },
});

// We don't need actual types because we need only SQL strings.
interface Database {
  evolu_message: {
    timestamp: string;
    table: string;
    row: string;
    column: string;
    value: unknown;
  };

  evolu_owner: {
    id: string;
    mnemonic: string;
    encryptionKey: Uint8Array;
    timestamp: string;
    merkleTree: string;
  };
}

const queries = {
  selectOwner: db
    .selectFrom("evolu_owner")
    .select(["id", "mnemonic", "encryptionKey"]),

  createMessageTable: db.schema
    .createTable("evolu_message")
    .addColumn("timestamp", "blob", (col) => col.primaryKey())
    .addColumn("table", "blob")
    .addColumn("row", "blob")
    .addColumn("column", "blob")
    .addColumn("value", "blob"),

  createMessageTableIndex: db.schema
    .createIndex("index_evolu_message")
    .on("evolu_message")
    .columns(["table", "row", "column", "timestamp desc"]),

  createOwnerTable: db.schema
    .createTable("evolu_owner")
    .addColumn("id", "blob")
    .addColumn("mnemonic", "blob")
    .addColumn("encryptionKey", "blob")
    .addColumn("timestamp", "blob")
    .addColumn("merkleTree", "blob"),

  insertOwner: db.insertInto("evolu_owner").values({
    id: "b",
    mnemonic: "a",
    encryptionKey: new Uint8Array(),
    timestamp: "a",
    merkleTree: "b",
  }),

  selectOwnerTimestampAndMerkleTree: db
    .selectFrom("evolu_owner")
    .select(["timestamp", "merkleTree"]),

  selectLastTimestampForTableRowColumn: db
    .selectFrom("evolu_message")
    .select("timestamp")
    .where("table", "=", "1")
    .where("row", "=", "2")
    .where("column", "=", "3")
    .orderBy("timestamp", "desc")
    .limit(1),

  insertIntoMessagesIfNew: db
    .insertInto("evolu_message")
    .values({
      timestamp: "1",
      table: "2",
      row: "3",
      column: "4",
      value: "5",
    })
    .onConflict((oc) => oc.doNothing()),

  updateOwnerTimestampAndMerkleTree: db.updateTable("evolu_owner").set({
    merkleTree: "1",
    timestamp: "2",
  }),

  selectMessagesToSync: db
    .selectFrom("evolu_message")
    .selectAll()
    .where("timestamp", ">=", "1")
    .orderBy("timestamp"),
};

pipe(
  queries,
  ReadonlyRecord.reduce(
    `
      // this file is generated by generateSql script
      import { SqliteQuery } from "./Sqlite.js";
    `,
    (acc, value, name) => {
      return (
        acc +
        `export const ${name}: SqliteQuery = { sql: \`${value.compile().sql}\`};\n\n`
      );
    },
  ),
  (string) =>
    Effect.promise(() => prettier.format(string, { parser: "typescript" })),
  Effect.runPromise,
).then((formattedString) => {
  fs.writeFileSync("./packages/evolu-common/src/Sql.ts", formattedString);
});
